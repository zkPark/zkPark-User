{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":2012364781912570682,"abi":{"parameters":[{"name":"lease_bytes","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"address_bytes","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"owner_id_bytes","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"lease_start","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"lease_end","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"daily_rate","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"space_features","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"expected_lease_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"expected_address_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"expected_owner_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"current_date","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"expected_rate","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"expected_features_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"62":{"source":"use dep::std::hash::sha256;\n\nglobal MAX_LEASE_DURATION: u64 = 3650;\n\nfn main(\n    lease_bytes: [u8; 128],\n    address_bytes: [u8; 64],\n    owner_id_bytes: [u8; 32],\n    lease_start: u64,\n    lease_end: u64,\n    daily_rate: u64,\n    space_features: [u8; 16],\n    signature: [u8; 64],\n    \n    expected_lease_hash: pub [u8; 32],\n    expected_address_hash: pub [u8; 32],\n    expected_owner_hash: pub [u8; 32],\n    current_date: pub u64,\n    expected_rate: pub u64,\n    expected_features_hash: pub [u8; 32]\n) {\n    let lease_duration = lease_end - lease_start;\n    assert(lease_duration > 0);\n    assert(lease_duration <= MAX_LEASE_DURATION * 86400);\n\n    let lease_hash = sha256(lease_bytes);\n    assert(lease_hash == expected_lease_hash);\n\n    let address_hash = sha256(address_bytes);\n    assert(address_hash == expected_address_hash);\n\n    let owner_hash = sha256(owner_id_bytes);\n    assert(owner_hash == expected_owner_hash);\n    assert(lease_start <= current_date);\n    assert(current_date <= lease_end);\n    assert(daily_rate == expected_rate);\n\n    let features_hash = sha256(space_features);\n    assert(features_hash == expected_features_hash);\n    verify_signature(lease_hash, address_hash, owner_hash, signature);\n}\n\n\nfn verify_signature(\n    lease_hash: [u8; 32],\n    address_hash: [u8; 32],\n    owner_hash: [u8; 32],\n    signature: [u8; 64]\n) {\n    let mut message: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        message[i] = lease_hash[i];\n    }\n    for i in 0..16 {\n        message[32 + i] = address_hash[i];\n    }\n    for i in 0..16 {\n        message[48 + i] = owner_hash[i];\n    }\n    \n    for i in 0..32 {\n        assert(signature[i] != 0);\n    }\n\n    let mut derived_id = [0; 32];\n    for i in 0..32 {\n        derived_id[i] = signature[32 + i] ^ signature[i];\n    }\n    assert(signature[0] != signature[32]);\n}","path":"/Users/vaibhav/Desktop/noirtest/circuits/lease/src/main.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","build_msg_block","build_msg_block","build_msg_block","directive_integer_quotient","directive_to_radix","directive_invert"]}